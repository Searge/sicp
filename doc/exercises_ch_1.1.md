# 1.1. Елементи програмування
## Вправа 1.1
Нижче наведена послідовність виразів. Який результат надрукує інтерпретатор у відповідь на кожне з них? Передбачається, що вирази вводяться у тому ж порядку, в якому написанні.

```racket
10
⇒  10
(+ 5 3 4)
⇒  12
(- 9 1)
⇒  8
(/ 6 2)
⇒  3
(+ (* 2 4) (- 4 6))
⇒  6
(define a 3)
(define b (+ a 1))
(+ a b (* a b))
;; тут думалка зламалася :-)
;; мабуть буде: 19
;; так і є o(〃＾▽＾〃)o
(= a b)
;; #f — тому що не рівне
(if (and (> b a) (< b (* a b))) b a)
⇒ 4
;; бо (4 > 3) і (4 < (12))

(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))
⇒ 16
;; альт. запис ↓
(cond
  (= a 4) 6
  (= b 4) (+ 6 7 a)
  :else 25)

(+ 2
  (if (> b a)
    b
    a))
⇒ 6; бо 4 + 2
(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
    (+ a 1))
⇒ 16; бо 4 * 4

```

## Вправа 1.2
Переведіть наступний вираз у префіксну форму:

![$`{5 + 4 (2 - (3 - (6 + {4 \over 5}))) \over 3(6 - 2)(2 - 7)}`$](https://latex.codecogs.com/gif.latex?{5&space;&plus;&space;4&space;(2&space;-&space;(3&space;-&space;(6&space;&plus;&space;{4&space;\over&space;5})))&space;\over&space;3(6&space;-&space;2)(2&space;-&space;7)})


```racket
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))
```

![$`-{37\over 150}`$](https://latex.codecogs.com/gif.latex?-{37\over&space;150})

## Вправа 1.3
Визначте процедуру, яка приймає в якості аргументів три числа і повертає суму квадратів двох найбільших із них.

```racket
(define (largest-sums x y z)
  (define (square x) (* x x))
  (define (max a b)
    (if (> a b) a b))
  (define (min a b)
    (if (< a b) a b))
  (+ (square (max x y)) (square (max (min x y) z)))
  )
```

Тут доволі прості процедури, хоча здаються геть неочевидними спочатку:
> `(+ (square (max x y)) (square (max (min x y) z)))`, якщо `x=1`, `y=0`, а `z=2`, то можна записати так: 

```lisp
 (((1 > 0) * (1 > 0)) + ((1 < 0) > 2) * ((1 < 0) > 2))
 ((   1    *    1   ) + (   0    > 2) * (   0    > 2))
```
> того що `max` вертає `1`, якщо `a>b`
> 
>       a `min` вертає `0`, якщо `a<b`
>       
> і в другому виразі ми маємо вкладений вираз `min` в `max`
> 
> тобто виходить, що `(min x y) = a`, а `z = b`
> 
> в виразі: `якщо a > b, a < b`, тоді повертається `b`, а не `a`

Є ще друге рішення, більш очевидне, з перебором варіантів (аналізом випадків):

```racket
(define (sum-larger-square a b c)
  (cond ((and (< a b) (< a c)) (+ (* b b) (* c c)))
        ((and (< b a) (< b c)) (+ (* a a) (* c c)))
        (else (+ (* a a) (* b b)))))
```

Тут все простіше:

```lisp
conditional (a < b) ⋀ (a < c) => b² + c²
            (b < a) ⋀ (b < c) => a² + c²
            інакше:           => a² + b²
```

## Вправа 1.4
Звернемо увагу, що наша модель обчислень дозволяє існування комбінацій, чиї оператори — складені вирази.
За допомогою цього спостереження, опишіть, як працює наступна процедура:

```racket
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
```

Вираз можна розкласти так:
`a` (якщо `b > 0`, тоді: `+`, інакше: `-`) `b`
> Тобто, якщо `b >= 0` повертає `+`, інакше — `-`,
> 
> але по-факту, яке б значення ми не підставляли все працює як плюс:

```racket
> (a-plus-abs-b 3 0.5)
3.5
> (a-plus-abs-b 3 -1)
4
> (a-plus-abs-b 3 0)
3
> (a-plus-abs-b 4 -3)
7
```

> Натомість: `(a-plus-abs-b -1 3)` повертає `2 ¯\_(ツ)_/¯`


## Вправа 1.5
Бен Бітобор вигадав тест для перевірки інтерпретатора на те, з яким порядком обчислень він працює, аплікативним чи нормальним. Бен визначає такі дві процедури:

```racket
(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))
```

Потім він обчислює вираз:

```racket
(test 0 (p))
```

Яку поведінку побачить Бен, якщо інтерпретатор використовує _аплікативний порядок_ обчислень?
Яку поведінку він побачить, якщо інтерпретатор використовує _нормальний порядок_?
Поясніть вашу відповідь. 
(Очікується, що правило обчислення _особливої форми_ `if` одинакове, незалежно від того, який порядк обчислень використовується. 
Спочатку обчислюється вираз-предикат, і результат визначає, потрібно обчислювати наслідок чи альтернативу).

#### При аплікативному порядку обчислень:
В цьому випадку операнд `y` буде обчислений за замовчуванням і отже буде повернений в рекурсії, адже `(p)` вказує на саму себе.

#### При нормальному порядку обчислення:
В цьому випадку операнд `(p)` не буде обчислюватися поки він не буде затребуваним якимись _прімитивними_ (базовими) операціями, отже цей вираз поверне `0`.








